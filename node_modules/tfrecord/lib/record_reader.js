"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const util_1 = require("util");
const crc32c_1 = require("./crc32c");
const fsOpen = util_1.promisify(fs.open);
const fsRead = util_1.promisify(fs.read);
const fsClose = util_1.promisify(fs.close);
class RecordReader {
    // Opens a TFRecord file and creates a RecordReader around it.
    static async create(filePath) {
        const fd = await fsOpen(filePath, 'r');
        return new RecordReader(fd);
    }
    // Reads a record from the file.
    //
    // Returns null when the end of the file is reached.
    //
    // The returned Uint8Array points to an internal buffer, and is only
    // guaranteed to be valid until the next readRecord() call.
    async readRecord() {
        if (this.closed_)
            return null;
        let { bytesRead } = await fsRead(this.fd_, this.lengthAndCrcBuffer_, 0, 12, null);
        if (bytesRead === 0)
            return null;
        if (bytesRead !== 12)
            throw new Error(`Incomplete read; expected 12 bytes, got ${bytesRead}`);
        const length = this.lengthAndCrc_.getUint32(0, true);
        const length64 = this.lengthAndCrc_.getUint32(4, true);
        const lengthCrc = this.lengthAndCrc_.getUint32(8, true);
        if (length64 !== 0)
            throw new Error(`4GB+ records not supported`);
        if (lengthCrc !== crc32c_1.maskedCrc32c(this.lengthBuffer_))
            throw new Error('Incorrect record length CRC32C');
        const readLength = length + 4; // Need to read the CRC32C as well.
        if (readLength > this.dataBuffer_.length) {
            // Grow the buffer.
            let newLength = this.dataBuffer_.length;
            while (newLength < readLength)
                newLength *= 2;
            this.dataBuffer_ = new Uint8Array(newLength);
            this.dataBufferView_ =
                new DataView(this.dataBuffer_.buffer, 0, newLength);
        }
        ({ bytesRead } =
            await fsRead(this.fd_, this.dataBuffer_, 0, readLength, null));
        if (bytesRead !== readLength) {
            throw new Error(`Incomplete read; expected ${readLength} bytes, got ${bytesRead}`);
        }
        const recordData = new Uint8Array(this.dataBuffer_.buffer, 0, length);
        const recordCrc = this.dataBufferView_.getUint32(length, true);
        // TODO(pwnall): Check CRC.
        const recordBuffer = Buffer.from(this.dataBuffer_.buffer, 0, length);
        if (recordCrc !== crc32c_1.maskedCrc32c(recordBuffer))
            throw new Error('Incorrect record CRC32C');
        return recordData;
    }
    // Closes the reader.
    //
    // The reader is automatically closed when it reaches the end of the file.
    // Closing is idempotent.
    async close() {
        if (this.closed_)
            return;
        this.closed_ = true;
        await fsClose(this.fd_);
    }
    // RecordReader instances should be created using RecordReader.create.
    constructor(fd) {
        this.fd_ = fd;
        this.closed_ = false;
        this.dataBuffer_ = new Uint8Array(1);
        this.dataBufferView_ = new DataView(this.dataBuffer_.buffer, 0, 1);
        const metadataBuffer = new ArrayBuffer(12);
        this.lengthAndCrcBuffer_ = new Uint8Array(metadataBuffer, 0, 12);
        this.lengthAndCrc_ = new DataView(metadataBuffer, 0, 12);
        this.lengthBuffer_ = Buffer.from(metadataBuffer, 0, 8);
    }
}
exports.RecordReader = RecordReader;
//# sourceMappingURL=record_reader.js.map