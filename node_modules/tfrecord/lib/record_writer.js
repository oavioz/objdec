"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const util_1 = require("util");
const crc32c_1 = require("./crc32c");
const fsOpen = util_1.promisify(fs.open);
const fsWrite = util_1.promisify(fs.write);
const fsClose = util_1.promisify(fs.close);
class RecordWriter {
    // Opens a TFRecord file and creates a RecordWriter around it.
    static async create(filePath) {
        const fd = await fsOpen(filePath, 'w');
        return new RecordWriter(fd);
    }
    // Writes a record to a buffer.
    //
    // Uses a Buffer instead of an Uint8Array because that's what protobuf.js
    // writes to.
    async writeRecord(record) {
        const length = record.length;
        this.lengthAndCrc_.setUint32(0, length, true);
        const lengthCrc = crc32c_1.maskedCrc32c(this.lengthBuffer_);
        this.lengthAndCrc_.setUint32(8, lengthCrc, true);
        let { bytesWritten } = await fsWrite(this.fd_, this.lengthAndCrcBuffer_, 0, 12, null);
        if (bytesWritten != 12)
            throw new Error(`Incomplete write; had 12 bytes, wrote ${bytesWritten}`);
        ({ bytesWritten } = await fsWrite(this.fd_, record, 0, length, null));
        if (bytesWritten != length) {
            throw new Error(`Incomplete write; had ${length} bytes, wrote ${bytesWritten}`);
        }
        const recordCrc = crc32c_1.maskedCrc32c(record);
        this.lengthAndCrc_.setUint32(0, recordCrc, true);
        ({ bytesWritten } =
            await fsWrite(this.fd_, this.lengthAndCrcBuffer_, 0, 4, null));
        if (bytesWritten != 4)
            throw new Error(`Incomplete write; had 4 bytes, wrote ${bytesWritten}`);
    }
    // RecordWriter instances should be created using RecordWriter.create.
    constructor(fd) {
        this.fd_ = fd;
        this.closed_ = false;
        const metadataBuffer = new ArrayBuffer(12);
        this.lengthAndCrcBuffer_ = new Uint8Array(metadataBuffer, 0, 12);
        this.lengthAndCrc_ = new DataView(metadataBuffer, 0, 12);
        this.lengthBuffer_ = Buffer.from(metadataBuffer, 0, 8);
        // The high-order bits of length will alwas be unset.
        this.lengthAndCrc_.setUint32(4, 0, true);
    }
    // Closes the writer.
    //
    // Closing is idempotent.
    async close() {
        if (this.closed_)
            return;
        this.closed_ = true;
        await fsClose(this.fd_);
    }
}
exports.RecordWriter = RecordWriter;
//# sourceMappingURL=record_writer.js.map