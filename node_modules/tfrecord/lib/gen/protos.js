/*eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.tensorflow = (function() {

    /**
     * Namespace tensorflow.
     * @exports tensorflow
     * @namespace
     */
    var tensorflow = {};

    tensorflow.Example = (function() {

        /**
         * Properties of an Example.
         * @memberof tensorflow
         * @interface IExample
         * @property {tensorflow.IFeatures|null} [features] Example features
         */

        /**
         * Constructs a new Example.
         * @memberof tensorflow
         * @classdesc Represents an Example.
         * @implements IExample
         * @constructor
         * @param {tensorflow.IExample=} [properties] Properties to set
         */
        function Example(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Example features.
         * @member {tensorflow.IFeatures|null|undefined} features
         * @memberof tensorflow.Example
         * @instance
         */
        Example.prototype.features = null;

        /**
         * Creates a new Example instance using the specified properties.
         * @function create
         * @memberof tensorflow.Example
         * @static
         * @param {tensorflow.IExample=} [properties] Properties to set
         * @returns {tensorflow.Example} Example instance
         */
        Example.create = function create(properties) {
            return new Example(properties);
        };

        /**
         * Encodes the specified Example message. Does not implicitly {@link tensorflow.Example.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.Example
         * @static
         * @param {tensorflow.IExample} message Example message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Example.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.features != null && message.hasOwnProperty("features"))
                $root.tensorflow.Features.encode(message.features, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Example message, length delimited. Does not implicitly {@link tensorflow.Example.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.Example
         * @static
         * @param {tensorflow.IExample} message Example message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Example.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Example message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.Example
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.Example} Example
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Example.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.Example();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.features = $root.tensorflow.Features.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Example message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.Example
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.Example} Example
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Example.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Example message.
         * @function verify
         * @memberof tensorflow.Example
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Example.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.features != null && message.hasOwnProperty("features")) {
                var error = $root.tensorflow.Features.verify(message.features);
                if (error)
                    return "features." + error;
            }
            return null;
        };

        /**
         * Creates an Example message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.Example
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.Example} Example
         */
        Example.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.Example)
                return object;
            var message = new $root.tensorflow.Example();
            if (object.features != null) {
                if (typeof object.features !== "object")
                    throw TypeError(".tensorflow.Example.features: object expected");
                message.features = $root.tensorflow.Features.fromObject(object.features);
            }
            return message;
        };

        /**
         * Creates a plain object from an Example message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.Example
         * @static
         * @param {tensorflow.Example} message Example
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Example.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.features = null;
            if (message.features != null && message.hasOwnProperty("features"))
                object.features = $root.tensorflow.Features.toObject(message.features, options);
            return object;
        };

        /**
         * Converts this Example to JSON.
         * @function toJSON
         * @memberof tensorflow.Example
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Example.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Example;
    })();

    tensorflow.SequenceExample = (function() {

        /**
         * Properties of a SequenceExample.
         * @memberof tensorflow
         * @interface ISequenceExample
         * @property {tensorflow.IFeatures|null} [context] SequenceExample context
         * @property {tensorflow.IFeatureLists|null} [featureLists] SequenceExample featureLists
         */

        /**
         * Constructs a new SequenceExample.
         * @memberof tensorflow
         * @classdesc Represents a SequenceExample.
         * @implements ISequenceExample
         * @constructor
         * @param {tensorflow.ISequenceExample=} [properties] Properties to set
         */
        function SequenceExample(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SequenceExample context.
         * @member {tensorflow.IFeatures|null|undefined} context
         * @memberof tensorflow.SequenceExample
         * @instance
         */
        SequenceExample.prototype.context = null;

        /**
         * SequenceExample featureLists.
         * @member {tensorflow.IFeatureLists|null|undefined} featureLists
         * @memberof tensorflow.SequenceExample
         * @instance
         */
        SequenceExample.prototype.featureLists = null;

        /**
         * Creates a new SequenceExample instance using the specified properties.
         * @function create
         * @memberof tensorflow.SequenceExample
         * @static
         * @param {tensorflow.ISequenceExample=} [properties] Properties to set
         * @returns {tensorflow.SequenceExample} SequenceExample instance
         */
        SequenceExample.create = function create(properties) {
            return new SequenceExample(properties);
        };

        /**
         * Encodes the specified SequenceExample message. Does not implicitly {@link tensorflow.SequenceExample.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.SequenceExample
         * @static
         * @param {tensorflow.ISequenceExample} message SequenceExample message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SequenceExample.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.context != null && message.hasOwnProperty("context"))
                $root.tensorflow.Features.encode(message.context, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.featureLists != null && message.hasOwnProperty("featureLists"))
                $root.tensorflow.FeatureLists.encode(message.featureLists, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SequenceExample message, length delimited. Does not implicitly {@link tensorflow.SequenceExample.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.SequenceExample
         * @static
         * @param {tensorflow.ISequenceExample} message SequenceExample message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SequenceExample.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SequenceExample message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.SequenceExample
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.SequenceExample} SequenceExample
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SequenceExample.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.SequenceExample();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.context = $root.tensorflow.Features.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.featureLists = $root.tensorflow.FeatureLists.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SequenceExample message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.SequenceExample
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.SequenceExample} SequenceExample
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SequenceExample.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SequenceExample message.
         * @function verify
         * @memberof tensorflow.SequenceExample
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SequenceExample.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.context != null && message.hasOwnProperty("context")) {
                var error = $root.tensorflow.Features.verify(message.context);
                if (error)
                    return "context." + error;
            }
            if (message.featureLists != null && message.hasOwnProperty("featureLists")) {
                var error = $root.tensorflow.FeatureLists.verify(message.featureLists);
                if (error)
                    return "featureLists." + error;
            }
            return null;
        };

        /**
         * Creates a SequenceExample message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.SequenceExample
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.SequenceExample} SequenceExample
         */
        SequenceExample.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.SequenceExample)
                return object;
            var message = new $root.tensorflow.SequenceExample();
            if (object.context != null) {
                if (typeof object.context !== "object")
                    throw TypeError(".tensorflow.SequenceExample.context: object expected");
                message.context = $root.tensorflow.Features.fromObject(object.context);
            }
            if (object.featureLists != null) {
                if (typeof object.featureLists !== "object")
                    throw TypeError(".tensorflow.SequenceExample.featureLists: object expected");
                message.featureLists = $root.tensorflow.FeatureLists.fromObject(object.featureLists);
            }
            return message;
        };

        /**
         * Creates a plain object from a SequenceExample message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.SequenceExample
         * @static
         * @param {tensorflow.SequenceExample} message SequenceExample
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SequenceExample.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.context = null;
                object.featureLists = null;
            }
            if (message.context != null && message.hasOwnProperty("context"))
                object.context = $root.tensorflow.Features.toObject(message.context, options);
            if (message.featureLists != null && message.hasOwnProperty("featureLists"))
                object.featureLists = $root.tensorflow.FeatureLists.toObject(message.featureLists, options);
            return object;
        };

        /**
         * Converts this SequenceExample to JSON.
         * @function toJSON
         * @memberof tensorflow.SequenceExample
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SequenceExample.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SequenceExample;
    })();

    tensorflow.BytesList = (function() {

        /**
         * Properties of a BytesList.
         * @memberof tensorflow
         * @interface IBytesList
         * @property {Array.<Uint8Array>|null} [value] BytesList value
         */

        /**
         * Constructs a new BytesList.
         * @memberof tensorflow
         * @classdesc Represents a BytesList.
         * @implements IBytesList
         * @constructor
         * @param {tensorflow.IBytesList=} [properties] Properties to set
         */
        function BytesList(properties) {
            this.value = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BytesList value.
         * @member {Array.<Uint8Array>} value
         * @memberof tensorflow.BytesList
         * @instance
         */
        BytesList.prototype.value = $util.emptyArray;

        /**
         * Creates a new BytesList instance using the specified properties.
         * @function create
         * @memberof tensorflow.BytesList
         * @static
         * @param {tensorflow.IBytesList=} [properties] Properties to set
         * @returns {tensorflow.BytesList} BytesList instance
         */
        BytesList.create = function create(properties) {
            return new BytesList(properties);
        };

        /**
         * Encodes the specified BytesList message. Does not implicitly {@link tensorflow.BytesList.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.BytesList
         * @static
         * @param {tensorflow.IBytesList} message BytesList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BytesList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && message.value.length)
                for (var i = 0; i < message.value.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value[i]);
            return writer;
        };

        /**
         * Encodes the specified BytesList message, length delimited. Does not implicitly {@link tensorflow.BytesList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.BytesList
         * @static
         * @param {tensorflow.IBytesList} message BytesList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BytesList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BytesList message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.BytesList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.BytesList} BytesList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BytesList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.BytesList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.value && message.value.length))
                        message.value = [];
                    message.value.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BytesList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.BytesList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.BytesList} BytesList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BytesList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BytesList message.
         * @function verify
         * @memberof tensorflow.BytesList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BytesList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.value != null && message.hasOwnProperty("value")) {
                if (!Array.isArray(message.value))
                    return "value: array expected";
                for (var i = 0; i < message.value.length; ++i)
                    if (!(message.value[i] && typeof message.value[i].length === "number" || $util.isString(message.value[i])))
                        return "value: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a BytesList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.BytesList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.BytesList} BytesList
         */
        BytesList.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.BytesList)
                return object;
            var message = new $root.tensorflow.BytesList();
            if (object.value) {
                if (!Array.isArray(object.value))
                    throw TypeError(".tensorflow.BytesList.value: array expected");
                message.value = [];
                for (var i = 0; i < object.value.length; ++i)
                    if (typeof object.value[i] === "string")
                        $util.base64.decode(object.value[i], message.value[i] = $util.newBuffer($util.base64.length(object.value[i])), 0);
                    else if (object.value[i].length)
                        message.value[i] = object.value[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a BytesList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.BytesList
         * @static
         * @param {tensorflow.BytesList} message BytesList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BytesList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.value = [];
            if (message.value && message.value.length) {
                object.value = [];
                for (var j = 0; j < message.value.length; ++j)
                    object.value[j] = options.bytes === String ? $util.base64.encode(message.value[j], 0, message.value[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.value[j]) : message.value[j];
            }
            return object;
        };

        /**
         * Converts this BytesList to JSON.
         * @function toJSON
         * @memberof tensorflow.BytesList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BytesList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BytesList;
    })();

    tensorflow.FloatList = (function() {

        /**
         * Properties of a FloatList.
         * @memberof tensorflow
         * @interface IFloatList
         * @property {Array.<number>|null} [value] FloatList value
         */

        /**
         * Constructs a new FloatList.
         * @memberof tensorflow
         * @classdesc Represents a FloatList.
         * @implements IFloatList
         * @constructor
         * @param {tensorflow.IFloatList=} [properties] Properties to set
         */
        function FloatList(properties) {
            this.value = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FloatList value.
         * @member {Array.<number>} value
         * @memberof tensorflow.FloatList
         * @instance
         */
        FloatList.prototype.value = $util.emptyArray;

        /**
         * Creates a new FloatList instance using the specified properties.
         * @function create
         * @memberof tensorflow.FloatList
         * @static
         * @param {tensorflow.IFloatList=} [properties] Properties to set
         * @returns {tensorflow.FloatList} FloatList instance
         */
        FloatList.create = function create(properties) {
            return new FloatList(properties);
        };

        /**
         * Encodes the specified FloatList message. Does not implicitly {@link tensorflow.FloatList.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.FloatList
         * @static
         * @param {tensorflow.IFloatList} message FloatList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FloatList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && message.value.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.value.length; ++i)
                    writer.float(message.value[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified FloatList message, length delimited. Does not implicitly {@link tensorflow.FloatList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.FloatList
         * @static
         * @param {tensorflow.IFloatList} message FloatList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FloatList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FloatList message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.FloatList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.FloatList} FloatList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FloatList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.FloatList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.value && message.value.length))
                        message.value = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.value.push(reader.float());
                    } else
                        message.value.push(reader.float());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FloatList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.FloatList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.FloatList} FloatList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FloatList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FloatList message.
         * @function verify
         * @memberof tensorflow.FloatList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FloatList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.value != null && message.hasOwnProperty("value")) {
                if (!Array.isArray(message.value))
                    return "value: array expected";
                for (var i = 0; i < message.value.length; ++i)
                    if (typeof message.value[i] !== "number")
                        return "value: number[] expected";
            }
            return null;
        };

        /**
         * Creates a FloatList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.FloatList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.FloatList} FloatList
         */
        FloatList.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.FloatList)
                return object;
            var message = new $root.tensorflow.FloatList();
            if (object.value) {
                if (!Array.isArray(object.value))
                    throw TypeError(".tensorflow.FloatList.value: array expected");
                message.value = [];
                for (var i = 0; i < object.value.length; ++i)
                    message.value[i] = Number(object.value[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a FloatList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.FloatList
         * @static
         * @param {tensorflow.FloatList} message FloatList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FloatList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.value = [];
            if (message.value && message.value.length) {
                object.value = [];
                for (var j = 0; j < message.value.length; ++j)
                    object.value[j] = options.json && !isFinite(message.value[j]) ? String(message.value[j]) : message.value[j];
            }
            return object;
        };

        /**
         * Converts this FloatList to JSON.
         * @function toJSON
         * @memberof tensorflow.FloatList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FloatList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FloatList;
    })();

    tensorflow.Int64List = (function() {

        /**
         * Properties of an Int64List.
         * @memberof tensorflow
         * @interface IInt64List
         * @property {Array.<number|Long>|null} [value] Int64List value
         */

        /**
         * Constructs a new Int64List.
         * @memberof tensorflow
         * @classdesc Represents an Int64List.
         * @implements IInt64List
         * @constructor
         * @param {tensorflow.IInt64List=} [properties] Properties to set
         */
        function Int64List(properties) {
            this.value = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Int64List value.
         * @member {Array.<number|Long>} value
         * @memberof tensorflow.Int64List
         * @instance
         */
        Int64List.prototype.value = $util.emptyArray;

        /**
         * Creates a new Int64List instance using the specified properties.
         * @function create
         * @memberof tensorflow.Int64List
         * @static
         * @param {tensorflow.IInt64List=} [properties] Properties to set
         * @returns {tensorflow.Int64List} Int64List instance
         */
        Int64List.create = function create(properties) {
            return new Int64List(properties);
        };

        /**
         * Encodes the specified Int64List message. Does not implicitly {@link tensorflow.Int64List.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.Int64List
         * @static
         * @param {tensorflow.IInt64List} message Int64List message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Int64List.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && message.value.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.value.length; ++i)
                    writer.int64(message.value[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified Int64List message, length delimited. Does not implicitly {@link tensorflow.Int64List.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.Int64List
         * @static
         * @param {tensorflow.IInt64List} message Int64List message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Int64List.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Int64List message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.Int64List
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.Int64List} Int64List
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Int64List.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.Int64List();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.value && message.value.length))
                        message.value = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.value.push(reader.int64());
                    } else
                        message.value.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Int64List message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.Int64List
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.Int64List} Int64List
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Int64List.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Int64List message.
         * @function verify
         * @memberof tensorflow.Int64List
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Int64List.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.value != null && message.hasOwnProperty("value")) {
                if (!Array.isArray(message.value))
                    return "value: array expected";
                for (var i = 0; i < message.value.length; ++i)
                    if (!$util.isInteger(message.value[i]) && !(message.value[i] && $util.isInteger(message.value[i].low) && $util.isInteger(message.value[i].high)))
                        return "value: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates an Int64List message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.Int64List
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.Int64List} Int64List
         */
        Int64List.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.Int64List)
                return object;
            var message = new $root.tensorflow.Int64List();
            if (object.value) {
                if (!Array.isArray(object.value))
                    throw TypeError(".tensorflow.Int64List.value: array expected");
                message.value = [];
                for (var i = 0; i < object.value.length; ++i)
                    if ($util.Long)
                        (message.value[i] = $util.Long.fromValue(object.value[i])).unsigned = false;
                    else if (typeof object.value[i] === "string")
                        message.value[i] = parseInt(object.value[i], 10);
                    else if (typeof object.value[i] === "number")
                        message.value[i] = object.value[i];
                    else if (typeof object.value[i] === "object")
                        message.value[i] = new $util.LongBits(object.value[i].low >>> 0, object.value[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from an Int64List message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.Int64List
         * @static
         * @param {tensorflow.Int64List} message Int64List
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Int64List.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.value = [];
            if (message.value && message.value.length) {
                object.value = [];
                for (var j = 0; j < message.value.length; ++j)
                    if (typeof message.value[j] === "number")
                        object.value[j] = options.longs === String ? String(message.value[j]) : message.value[j];
                    else
                        object.value[j] = options.longs === String ? $util.Long.prototype.toString.call(message.value[j]) : options.longs === Number ? new $util.LongBits(message.value[j].low >>> 0, message.value[j].high >>> 0).toNumber() : message.value[j];
            }
            return object;
        };

        /**
         * Converts this Int64List to JSON.
         * @function toJSON
         * @memberof tensorflow.Int64List
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Int64List.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Int64List;
    })();

    tensorflow.Feature = (function() {

        /**
         * Properties of a Feature.
         * @memberof tensorflow
         * @interface IFeature
         * @property {tensorflow.IBytesList|null} [bytesList] Feature bytesList
         * @property {tensorflow.IFloatList|null} [floatList] Feature floatList
         * @property {tensorflow.IInt64List|null} [int64List] Feature int64List
         */

        /**
         * Constructs a new Feature.
         * @memberof tensorflow
         * @classdesc Represents a Feature.
         * @implements IFeature
         * @constructor
         * @param {tensorflow.IFeature=} [properties] Properties to set
         */
        function Feature(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Feature bytesList.
         * @member {tensorflow.IBytesList|null|undefined} bytesList
         * @memberof tensorflow.Feature
         * @instance
         */
        Feature.prototype.bytesList = null;

        /**
         * Feature floatList.
         * @member {tensorflow.IFloatList|null|undefined} floatList
         * @memberof tensorflow.Feature
         * @instance
         */
        Feature.prototype.floatList = null;

        /**
         * Feature int64List.
         * @member {tensorflow.IInt64List|null|undefined} int64List
         * @memberof tensorflow.Feature
         * @instance
         */
        Feature.prototype.int64List = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Feature kind.
         * @member {"bytesList"|"floatList"|"int64List"|undefined} kind
         * @memberof tensorflow.Feature
         * @instance
         */
        Object.defineProperty(Feature.prototype, "kind", {
            get: $util.oneOfGetter($oneOfFields = ["bytesList", "floatList", "int64List"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Feature instance using the specified properties.
         * @function create
         * @memberof tensorflow.Feature
         * @static
         * @param {tensorflow.IFeature=} [properties] Properties to set
         * @returns {tensorflow.Feature} Feature instance
         */
        Feature.create = function create(properties) {
            return new Feature(properties);
        };

        /**
         * Encodes the specified Feature message. Does not implicitly {@link tensorflow.Feature.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.Feature
         * @static
         * @param {tensorflow.IFeature} message Feature message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Feature.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bytesList != null && message.hasOwnProperty("bytesList"))
                $root.tensorflow.BytesList.encode(message.bytesList, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.floatList != null && message.hasOwnProperty("floatList"))
                $root.tensorflow.FloatList.encode(message.floatList, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.int64List != null && message.hasOwnProperty("int64List"))
                $root.tensorflow.Int64List.encode(message.int64List, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Feature message, length delimited. Does not implicitly {@link tensorflow.Feature.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.Feature
         * @static
         * @param {tensorflow.IFeature} message Feature message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Feature.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Feature message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.Feature
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.Feature} Feature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Feature.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.Feature();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bytesList = $root.tensorflow.BytesList.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.floatList = $root.tensorflow.FloatList.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.int64List = $root.tensorflow.Int64List.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Feature message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.Feature
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.Feature} Feature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Feature.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Feature message.
         * @function verify
         * @memberof tensorflow.Feature
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Feature.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.bytesList != null && message.hasOwnProperty("bytesList")) {
                properties.kind = 1;
                {
                    var error = $root.tensorflow.BytesList.verify(message.bytesList);
                    if (error)
                        return "bytesList." + error;
                }
            }
            if (message.floatList != null && message.hasOwnProperty("floatList")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                {
                    var error = $root.tensorflow.FloatList.verify(message.floatList);
                    if (error)
                        return "floatList." + error;
                }
            }
            if (message.int64List != null && message.hasOwnProperty("int64List")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                {
                    var error = $root.tensorflow.Int64List.verify(message.int64List);
                    if (error)
                        return "int64List." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Feature message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.Feature
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.Feature} Feature
         */
        Feature.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.Feature)
                return object;
            var message = new $root.tensorflow.Feature();
            if (object.bytesList != null) {
                if (typeof object.bytesList !== "object")
                    throw TypeError(".tensorflow.Feature.bytesList: object expected");
                message.bytesList = $root.tensorflow.BytesList.fromObject(object.bytesList);
            }
            if (object.floatList != null) {
                if (typeof object.floatList !== "object")
                    throw TypeError(".tensorflow.Feature.floatList: object expected");
                message.floatList = $root.tensorflow.FloatList.fromObject(object.floatList);
            }
            if (object.int64List != null) {
                if (typeof object.int64List !== "object")
                    throw TypeError(".tensorflow.Feature.int64List: object expected");
                message.int64List = $root.tensorflow.Int64List.fromObject(object.int64List);
            }
            return message;
        };

        /**
         * Creates a plain object from a Feature message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.Feature
         * @static
         * @param {tensorflow.Feature} message Feature
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Feature.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.bytesList != null && message.hasOwnProperty("bytesList")) {
                object.bytesList = $root.tensorflow.BytesList.toObject(message.bytesList, options);
                if (options.oneofs)
                    object.kind = "bytesList";
            }
            if (message.floatList != null && message.hasOwnProperty("floatList")) {
                object.floatList = $root.tensorflow.FloatList.toObject(message.floatList, options);
                if (options.oneofs)
                    object.kind = "floatList";
            }
            if (message.int64List != null && message.hasOwnProperty("int64List")) {
                object.int64List = $root.tensorflow.Int64List.toObject(message.int64List, options);
                if (options.oneofs)
                    object.kind = "int64List";
            }
            return object;
        };

        /**
         * Converts this Feature to JSON.
         * @function toJSON
         * @memberof tensorflow.Feature
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Feature.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Feature;
    })();

    tensorflow.Features = (function() {

        /**
         * Properties of a Features.
         * @memberof tensorflow
         * @interface IFeatures
         * @property {Object.<string,tensorflow.IFeature>|null} [feature] Features feature
         */

        /**
         * Constructs a new Features.
         * @memberof tensorflow
         * @classdesc Represents a Features.
         * @implements IFeatures
         * @constructor
         * @param {tensorflow.IFeatures=} [properties] Properties to set
         */
        function Features(properties) {
            this.feature = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Features feature.
         * @member {Object.<string,tensorflow.IFeature>} feature
         * @memberof tensorflow.Features
         * @instance
         */
        Features.prototype.feature = $util.emptyObject;

        /**
         * Creates a new Features instance using the specified properties.
         * @function create
         * @memberof tensorflow.Features
         * @static
         * @param {tensorflow.IFeatures=} [properties] Properties to set
         * @returns {tensorflow.Features} Features instance
         */
        Features.create = function create(properties) {
            return new Features(properties);
        };

        /**
         * Encodes the specified Features message. Does not implicitly {@link tensorflow.Features.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.Features
         * @static
         * @param {tensorflow.IFeatures} message Features message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Features.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.feature != null && message.hasOwnProperty("feature"))
                for (var keys = Object.keys(message.feature), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.tensorflow.Feature.encode(message.feature[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified Features message, length delimited. Does not implicitly {@link tensorflow.Features.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.Features
         * @static
         * @param {tensorflow.IFeatures} message Features message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Features.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Features message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.Features
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.Features} Features
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Features.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.Features(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    reader.skip().pos++;
                    if (message.feature === $util.emptyObject)
                        message.feature = {};
                    key = reader.string();
                    reader.pos++;
                    message.feature[key] = $root.tensorflow.Feature.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Features message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.Features
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.Features} Features
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Features.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Features message.
         * @function verify
         * @memberof tensorflow.Features
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Features.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.feature != null && message.hasOwnProperty("feature")) {
                if (!$util.isObject(message.feature))
                    return "feature: object expected";
                var key = Object.keys(message.feature);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.tensorflow.Feature.verify(message.feature[key[i]]);
                    if (error)
                        return "feature." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Features message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.Features
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.Features} Features
         */
        Features.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.Features)
                return object;
            var message = new $root.tensorflow.Features();
            if (object.feature) {
                if (typeof object.feature !== "object")
                    throw TypeError(".tensorflow.Features.feature: object expected");
                message.feature = {};
                for (var keys = Object.keys(object.feature), i = 0; i < keys.length; ++i) {
                    if (typeof object.feature[keys[i]] !== "object")
                        throw TypeError(".tensorflow.Features.feature: object expected");
                    message.feature[keys[i]] = $root.tensorflow.Feature.fromObject(object.feature[keys[i]]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Features message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.Features
         * @static
         * @param {tensorflow.Features} message Features
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Features.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.feature = {};
            var keys2;
            if (message.feature && (keys2 = Object.keys(message.feature)).length) {
                object.feature = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.feature[keys2[j]] = $root.tensorflow.Feature.toObject(message.feature[keys2[j]], options);
            }
            return object;
        };

        /**
         * Converts this Features to JSON.
         * @function toJSON
         * @memberof tensorflow.Features
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Features.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Features;
    })();

    tensorflow.FeatureList = (function() {

        /**
         * Properties of a FeatureList.
         * @memberof tensorflow
         * @interface IFeatureList
         * @property {Array.<tensorflow.IFeature>|null} [feature] FeatureList feature
         */

        /**
         * Constructs a new FeatureList.
         * @memberof tensorflow
         * @classdesc Represents a FeatureList.
         * @implements IFeatureList
         * @constructor
         * @param {tensorflow.IFeatureList=} [properties] Properties to set
         */
        function FeatureList(properties) {
            this.feature = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FeatureList feature.
         * @member {Array.<tensorflow.IFeature>} feature
         * @memberof tensorflow.FeatureList
         * @instance
         */
        FeatureList.prototype.feature = $util.emptyArray;

        /**
         * Creates a new FeatureList instance using the specified properties.
         * @function create
         * @memberof tensorflow.FeatureList
         * @static
         * @param {tensorflow.IFeatureList=} [properties] Properties to set
         * @returns {tensorflow.FeatureList} FeatureList instance
         */
        FeatureList.create = function create(properties) {
            return new FeatureList(properties);
        };

        /**
         * Encodes the specified FeatureList message. Does not implicitly {@link tensorflow.FeatureList.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.FeatureList
         * @static
         * @param {tensorflow.IFeatureList} message FeatureList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeatureList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.feature != null && message.feature.length)
                for (var i = 0; i < message.feature.length; ++i)
                    $root.tensorflow.Feature.encode(message.feature[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FeatureList message, length delimited. Does not implicitly {@link tensorflow.FeatureList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.FeatureList
         * @static
         * @param {tensorflow.IFeatureList} message FeatureList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeatureList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeatureList message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.FeatureList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.FeatureList} FeatureList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeatureList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.FeatureList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.feature && message.feature.length))
                        message.feature = [];
                    message.feature.push($root.tensorflow.Feature.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeatureList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.FeatureList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.FeatureList} FeatureList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeatureList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeatureList message.
         * @function verify
         * @memberof tensorflow.FeatureList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeatureList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.feature != null && message.hasOwnProperty("feature")) {
                if (!Array.isArray(message.feature))
                    return "feature: array expected";
                for (var i = 0; i < message.feature.length; ++i) {
                    var error = $root.tensorflow.Feature.verify(message.feature[i]);
                    if (error)
                        return "feature." + error;
                }
            }
            return null;
        };

        /**
         * Creates a FeatureList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.FeatureList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.FeatureList} FeatureList
         */
        FeatureList.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.FeatureList)
                return object;
            var message = new $root.tensorflow.FeatureList();
            if (object.feature) {
                if (!Array.isArray(object.feature))
                    throw TypeError(".tensorflow.FeatureList.feature: array expected");
                message.feature = [];
                for (var i = 0; i < object.feature.length; ++i) {
                    if (typeof object.feature[i] !== "object")
                        throw TypeError(".tensorflow.FeatureList.feature: object expected");
                    message.feature[i] = $root.tensorflow.Feature.fromObject(object.feature[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a FeatureList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.FeatureList
         * @static
         * @param {tensorflow.FeatureList} message FeatureList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeatureList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.feature = [];
            if (message.feature && message.feature.length) {
                object.feature = [];
                for (var j = 0; j < message.feature.length; ++j)
                    object.feature[j] = $root.tensorflow.Feature.toObject(message.feature[j], options);
            }
            return object;
        };

        /**
         * Converts this FeatureList to JSON.
         * @function toJSON
         * @memberof tensorflow.FeatureList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeatureList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FeatureList;
    })();

    tensorflow.FeatureLists = (function() {

        /**
         * Properties of a FeatureLists.
         * @memberof tensorflow
         * @interface IFeatureLists
         * @property {Object.<string,tensorflow.IFeatureList>|null} [featureList] FeatureLists featureList
         */

        /**
         * Constructs a new FeatureLists.
         * @memberof tensorflow
         * @classdesc Represents a FeatureLists.
         * @implements IFeatureLists
         * @constructor
         * @param {tensorflow.IFeatureLists=} [properties] Properties to set
         */
        function FeatureLists(properties) {
            this.featureList = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FeatureLists featureList.
         * @member {Object.<string,tensorflow.IFeatureList>} featureList
         * @memberof tensorflow.FeatureLists
         * @instance
         */
        FeatureLists.prototype.featureList = $util.emptyObject;

        /**
         * Creates a new FeatureLists instance using the specified properties.
         * @function create
         * @memberof tensorflow.FeatureLists
         * @static
         * @param {tensorflow.IFeatureLists=} [properties] Properties to set
         * @returns {tensorflow.FeatureLists} FeatureLists instance
         */
        FeatureLists.create = function create(properties) {
            return new FeatureLists(properties);
        };

        /**
         * Encodes the specified FeatureLists message. Does not implicitly {@link tensorflow.FeatureLists.verify|verify} messages.
         * @function encode
         * @memberof tensorflow.FeatureLists
         * @static
         * @param {tensorflow.IFeatureLists} message FeatureLists message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeatureLists.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.featureList != null && message.hasOwnProperty("featureList"))
                for (var keys = Object.keys(message.featureList), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.tensorflow.FeatureList.encode(message.featureList[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified FeatureLists message, length delimited. Does not implicitly {@link tensorflow.FeatureLists.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tensorflow.FeatureLists
         * @static
         * @param {tensorflow.IFeatureLists} message FeatureLists message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeatureLists.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeatureLists message from the specified reader or buffer.
         * @function decode
         * @memberof tensorflow.FeatureLists
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tensorflow.FeatureLists} FeatureLists
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeatureLists.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tensorflow.FeatureLists(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    reader.skip().pos++;
                    if (message.featureList === $util.emptyObject)
                        message.featureList = {};
                    key = reader.string();
                    reader.pos++;
                    message.featureList[key] = $root.tensorflow.FeatureList.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeatureLists message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tensorflow.FeatureLists
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tensorflow.FeatureLists} FeatureLists
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeatureLists.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeatureLists message.
         * @function verify
         * @memberof tensorflow.FeatureLists
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeatureLists.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.featureList != null && message.hasOwnProperty("featureList")) {
                if (!$util.isObject(message.featureList))
                    return "featureList: object expected";
                var key = Object.keys(message.featureList);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.tensorflow.FeatureList.verify(message.featureList[key[i]]);
                    if (error)
                        return "featureList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a FeatureLists message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tensorflow.FeatureLists
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tensorflow.FeatureLists} FeatureLists
         */
        FeatureLists.fromObject = function fromObject(object) {
            if (object instanceof $root.tensorflow.FeatureLists)
                return object;
            var message = new $root.tensorflow.FeatureLists();
            if (object.featureList) {
                if (typeof object.featureList !== "object")
                    throw TypeError(".tensorflow.FeatureLists.featureList: object expected");
                message.featureList = {};
                for (var keys = Object.keys(object.featureList), i = 0; i < keys.length; ++i) {
                    if (typeof object.featureList[keys[i]] !== "object")
                        throw TypeError(".tensorflow.FeatureLists.featureList: object expected");
                    message.featureList[keys[i]] = $root.tensorflow.FeatureList.fromObject(object.featureList[keys[i]]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a FeatureLists message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tensorflow.FeatureLists
         * @static
         * @param {tensorflow.FeatureLists} message FeatureLists
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeatureLists.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.featureList = {};
            var keys2;
            if (message.featureList && (keys2 = Object.keys(message.featureList)).length) {
                object.featureList = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.featureList[keys2[j]] = $root.tensorflow.FeatureList.toObject(message.featureList[keys2[j]], options);
            }
            return object;
        };

        /**
         * Converts this FeatureLists to JSON.
         * @function toJSON
         * @memberof tensorflow.FeatureLists
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeatureLists.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FeatureLists;
    })();

    return tensorflow;
})();

module.exports = $root;
