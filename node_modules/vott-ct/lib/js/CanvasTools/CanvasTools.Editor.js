"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasTools_Filter_1 = require("./CanvasTools.Filter");
const Rect_1 = require("./Core/Rect");
const RegionsManager_1 = require("./Region/RegionsManager");
const AreaSelector_1 = require("./Selection/AreaSelector");
const ToolbarIcon_1 = require("./Toolbar/ToolbarIcon");
const Toolbar_1 = require("./Toolbar/Toolbar");
class Editor {
    constructor(editorZone) {
        this.isRMFrozen = false;
        this.autoResize = true;
        this.contentCanvas = this.createCanvasElement();
        this.editorSVG = this.createSVGElement();
        this.editorDiv = editorZone;
        this.editorDiv.classList.add("CanvasToolsEditor");
        this.editorDiv.append(this.contentCanvas);
        this.editorDiv.append(this.editorSVG);
        window.addEventListener("resize", (e) => {
            if (this.autoResize) {
                this.resize(this.editorDiv.offsetWidth, this.editorDiv.offsetHeight);
            }
        });
        this.regionsManager = new RegionsManager_1.RegionsManager(this.editorSVG, (region) => {
            this.areaSelector.hide();
            this.onRegionManipulationBegin(region);
        }, (region) => {
            this.areaSelector.show();
            this.onRegionManipulationEnd(region);
        });
        this.regionsManager.onRegionSelected = (id, multiselection) => {
            this.onRegionSelected(id, multiselection);
        };
        this.regionsManager.onRegionMove = (id, regionData) => {
            this.onRegionMove(id, regionData);
        };
        this.regionsManager.onRegionDelete = (id) => {
            this.onRegionDelete(id);
        };
        this.areaSelector = new AreaSelector_1.AreaSelector(this.editorSVG, {
            onSelectionBegin: () => {
                this.isRMFrozen = this.regionsManager.isFrozen;
                this.regionsManager.freeze();
                this.onSelectionBegin();
            },
            onSelectionEnd: (regionData) => {
                if (!this.isRMFrozen) {
                    this.regionsManager.unfreeze();
                }
                this.onSelectionEnd(regionData);
            }
        });
        this.filterPipeline = new CanvasTools_Filter_1.FilterPipeline();
        this.resize(editorZone.offsetWidth, editorZone.offsetHeight);
    }
    createSVGElement() {
        let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.innerHTML = Editor.SVGDefsTemplate;
        return svg;
    }
    createCanvasElement() {
        let canvas = document.createElement("canvas");
        return canvas;
    }
    onRegionManipulationBegin(region) {
    }
    onRegionManipulationEnd(region) {
    }
    onRegionSelected(id, multiselection) {
    }
    onRegionMove(id, regionData) {
    }
    onRegionDelete(id) {
    }
    onSelectionBegin() {
    }
    onSelectionEnd(commit) {
    }
    addToolbar(toolbarZone, toolbarSet, iconsPath) {
        let svg = this.createSVGElement();
        toolbarZone.append(svg);
        this.toolbar = new Toolbar_1.Toolbar(svg);
        if (toolbarSet === null) {
            toolbarSet = Editor.FullToolbarSet;
        }
        let activeSelector;
        toolbarSet.forEach((item) => {
            if (item.type == ToolbarIcon_1.ToolbarItemType.SEPARATOR) {
                this.toolbar.addSeparator();
            }
            else if (item.type == ToolbarIcon_1.ToolbarItemType.SELECTOR) {
                this.toolbar.addSelector({
                    action: item.action,
                    iconUrl: iconsPath + item.iconFile,
                    tooltip: item.tooltip,
                    keycode: item.keycode,
                    width: item.width,
                    height: item.height
                }, (action) => {
                    item.actionCallback(action, this.regionsManager, this.areaSelector);
                });
                if (item.activate) {
                    activeSelector = item.action;
                }
            }
            else if (item.type == ToolbarIcon_1.ToolbarItemType.SWITCH) {
                this.toolbar.addSwitch({
                    action: item.action,
                    iconUrl: iconsPath + item.iconFile,
                    tooltip: item.tooltip,
                    keycode: item.keycode,
                    width: item.width,
                    height: item.height
                }, (action) => {
                    item.actionCallback(action, this.regionsManager, this.areaSelector);
                });
                this.toolbar.setSwitch(item.action, item.activate);
            }
        });
        this.toolbar.select(activeSelector);
    }
    async addContentSource(source) {
        let buffCnvs = document.createElement("canvas");
        let context = buffCnvs.getContext("2d");
        if (source instanceof HTMLImageElement || source instanceof HTMLCanvasElement) {
            this.sourceWidth = source.width;
            this.sourceHeight = source.height;
        }
        else if (source instanceof HTMLVideoElement) {
            this.sourceWidth = source.videoWidth;
            this.sourceHeight = source.videoHeight;
        }
        buffCnvs.width = this.sourceWidth;
        buffCnvs.height = this.sourceHeight;
        context.drawImage(source, 0, 0, buffCnvs.width, buffCnvs.height);
        return this.filterPipeline.applyToCanvas(buffCnvs).then((bcnvs) => {
            this.contentCanvas.width = bcnvs.width;
            this.contentCanvas.height = bcnvs.height;
            let imgContext = this.contentCanvas.getContext("2d");
            imgContext.drawImage(bcnvs, 0, 0, bcnvs.width, bcnvs.height);
        }).then(() => {
            this.resize(this.editorDiv.offsetWidth, this.editorDiv.offsetHeight);
        });
    }
    resize(containerWidth, containerHeight) {
        this.frameWidth = containerWidth;
        this.frameHeight = containerHeight;
        let imgRatio = this.contentCanvas.width / this.contentCanvas.height;
        let containerRatio = containerWidth / containerHeight;
        let hpadding = 0;
        let vpadding = 0;
        if (imgRatio > containerRatio) {
            vpadding = (containerHeight - containerWidth / imgRatio) / 2;
            this.editorDiv.style.height = `calc(100% - ${vpadding * 2}px)`;
            this.editorDiv.style.width = "";
        }
        else {
            hpadding = (containerWidth - containerHeight * imgRatio) / 2;
            this.editorDiv.style.height = "";
            this.editorDiv.style.width = `calc(100% - ${hpadding * 2}px)`;
        }
        this.editorDiv.style.padding = `${vpadding}px ${hpadding}px`;
        this.frameWidth = this.editorSVG.clientWidth;
        this.frameHeight = this.editorSVG.clientHeight;
        this.areaSelector.resize(this.frameWidth, this.frameHeight);
        this.regionsManager.resize(this.frameWidth, this.frameHeight);
    }
    get RM() {
        return this.regionsManager;
    }
    get FilterPipeline() {
        return this.filterPipeline;
    }
    scaleRegionToSourceSize(regionData, sourceWidth, sourceHeight) {
        let sw = (sourceWidth !== undefined) ? sourceWidth : this.sourceWidth;
        let sh = (sourceHeight !== undefined) ? sourceHeight : this.sourceHeight;
        let xf = sw / this.frameWidth;
        let yf = sh / this.frameHeight;
        let rd = regionData.copy();
        rd.scale(xf, yf);
        return rd;
    }
    scaleRegionToFrameSize(regionData, sourceWidth, sourceHeight) {
        let sw = (sourceWidth !== undefined) ? sourceWidth : this.sourceWidth;
        let sh = (sourceHeight !== undefined) ? sourceHeight : this.sourceHeight;
        let xf = this.frameWidth / sw;
        let yf = this.frameHeight / sh;
        let rd = regionData.copy();
        rd.scale(xf, yf);
        return rd;
    }
}
Editor.SVGDefsTemplate = `
        <defs>
            <filter id="black-glow">
                <feGaussianBlur in="SourceAlpha" stdDeviation="2" />
                <feOffset dx="0" dy="0" result="offsetblur" />
                <feComponentTransfer>
                    <feFuncA type="linear" slope="0.8" />
                </feComponentTransfer>
                <feMerge>
                    <feMergeNode />
                    <feMergeNode in="SourceGraphic" />
                </feMerge>
            </filter>
        </defs>`;
Editor.FullToolbarSet = [
    {
        type: ToolbarIcon_1.ToolbarItemType.SELECTOR,
        action: "none-select",
        iconFile: "none-selection.svg",
        tooltip: "Regions Manipulation (M)",
        keycode: 'KeyM',
        actionCallback: (action, rm, sl) => {
            sl.setSelectionMode(AreaSelector_1.SelectionMode.NONE);
        },
        activate: false
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SEPARATOR
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SELECTOR,
        action: "point-select",
        iconFile: "point-selection.svg",
        tooltip: "Point-selection (P)",
        keycode: 'KeyP',
        actionCallback: (action, rm, sl) => {
            sl.setSelectionMode(AreaSelector_1.SelectionMode.POINT);
        },
        activate: false
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SELECTOR,
        action: "rect-select",
        iconFile: "rect-selection.svg",
        tooltip: "Rectangular box (R)",
        keycode: 'KeyR',
        actionCallback: (action, rm, sl) => {
            sl.setSelectionMode(AreaSelector_1.SelectionMode.RECT);
        },
        activate: true
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SELECTOR,
        action: "copy-select",
        iconFile: "copy-t-selection.svg",
        tooltip: "Template-based box (T)",
        keycode: 'KeyT',
        actionCallback: (action, rm, sl) => {
            let rs = rm.getSelectedRegionsBounds();
            if (rs !== undefined && rs.length > 0) {
                let r = rs[0];
                sl.setSelectionMode(AreaSelector_1.SelectionMode.COPYRECT, { template: new Rect_1.Rect(r.width, r.height) });
            }
            else {
                sl.setSelectionMode(AreaSelector_1.SelectionMode.COPYRECT, { template: new Rect_1.Rect(40, 40) });
            }
        },
        activate: false
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SELECTOR,
        action: "polyline-select",
        iconFile: "polyline-selection.svg",
        tooltip: "Polyline-selection (Y)",
        keycode: 'KeyY',
        actionCallback: (action, rm, sl) => {
            sl.setSelectionMode(AreaSelector_1.SelectionMode.POLYLINE);
        },
        activate: false
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SELECTOR,
        action: "polygon-select",
        iconFile: "polygon-selection.svg",
        tooltip: "Polygon-selection (O)",
        keycode: 'KeyO',
        actionCallback: (action, rm, sl) => {
            sl.setSelectionMode(AreaSelector_1.SelectionMode.POLYGON);
        },
        activate: false
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SEPARATOR
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SWITCH,
        action: "selection-lock",
        iconFile: "selection-lock.svg",
        tooltip: "Lock/unlock regions (L)",
        keycode: 'KeyL',
        actionCallback: (action, rm, sl) => {
            rm.toggleFreezeMode();
        },
        activate: false
    }
];
Editor.RectToolbarSet = [
    {
        type: ToolbarIcon_1.ToolbarItemType.SELECTOR,
        action: "none-select",
        iconFile: "none-selection.svg",
        tooltip: "Regions Manipulation (M)",
        keycode: 'KeyM',
        actionCallback: (action, rm, sl) => {
            sl.setSelectionMode(AreaSelector_1.SelectionMode.NONE);
        },
        activate: false
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SEPARATOR
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SELECTOR,
        action: "rect-select",
        iconFile: "rect-selection.svg",
        tooltip: "Rectangular box (R)",
        keycode: 'KeyR',
        actionCallback: (action, rm, sl) => {
            sl.setSelectionMode(AreaSelector_1.SelectionMode.RECT);
        },
        activate: true
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SELECTOR,
        action: "copy-select",
        iconFile: "copy-t-selection.svg",
        tooltip: "Template-based box (T)",
        keycode: 'KeyT',
        actionCallback: (action, rm, sl) => {
            let rs = rm.getSelectedRegionsBounds();
            if (rs !== undefined && rs.length > 0) {
                let r = rs[0];
                sl.setSelectionMode(AreaSelector_1.SelectionMode.COPYRECT, { template: new Rect_1.Rect(r.width, r.height) });
            }
            else {
                sl.setSelectionMode(AreaSelector_1.SelectionMode.COPYRECT, { template: new Rect_1.Rect(40, 40) });
            }
        },
        activate: false
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SEPARATOR
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SWITCH,
        action: "selection-lock",
        iconFile: "selection-lock.svg",
        tooltip: "Lock/unlock regions (L)",
        keycode: 'KeyL',
        actionCallback: (action, rm, sl) => {
            rm.toggleFreezeMode();
        },
        activate: false
    }
];
exports.Editor = Editor;
//# sourceMappingURL=CanvasTools.Editor.js.map