"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Point2D_1 = require("../../Core/Point2D");
const IRegionCallbacks_1 = require("../../Interface/IRegionCallbacks");
const AnchorsComponent_1 = require("../Component/AnchorsComponent");
class AnchorsElement extends AnchorsComponent_1.AnchorsComponent {
    constructor(paper, paperRect = null, regionData, callbacks) {
        super(paper, paperRect, regionData, callbacks);
    }
    buildPointAnchors() {
        this.anchorStyles = ["TL", "TR", "BR", "BL"];
        this.regionData.points.forEach((point, index) => {
            const anchor = this.createAnchor(this.paper, point.x, point.y, this.anchorStyles[index]);
            this.anchors.push(anchor);
            this.anchorsNode.add(anchor);
            this.subscribeAnchorToEvents(anchor, index);
        });
    }
    getActiveAnchor() {
        return (this.activeAnchorIndex >= 0) ? this.anchorStyles[this.activeAnchorIndex] : "";
    }
    updateRegion(p) {
        let x1 = p.x;
        let y1 = p.y;
        let x2;
        let y2;
        let flipX = false;
        let flipY = false;
        let activeAnchor = this.getActiveAnchor();
        switch (this.getActiveAnchor()) {
            case "TL": {
                x2 = this.x + this.width;
                y2 = this.y + this.height;
                flipX = x2 < x1;
                flipY = y2 < y1;
                break;
            }
            case "TR": {
                x2 = this.x;
                y2 = this.y + this.height;
                flipX = x1 < x2;
                flipY = y2 < y1;
                break;
            }
            case "BL": {
                y2 = this.y;
                x2 = this.x + this.width;
                flipX = x2 < x1;
                flipY = y1 < y2;
                break;
            }
            case "BR": {
                x2 = this.x;
                y2 = this.y;
                flipX = x1 < x2;
                flipY = y1 < y2;
                break;
            }
        }
        let newAA = "";
        if (activeAnchor !== "") {
            newAA += (activeAnchor[0] === "T") ? (flipY ? "B" : "T") : (flipY ? "T" : "B");
            newAA += (activeAnchor[1] === "L") ? (flipX ? "R" : "L") : (flipX ? "L" : "R");
        }
        if (activeAnchor !== newAA) {
            this.ghostAnchor.removeClass(activeAnchor);
            this.activeAnchorIndex = this.anchorStyles.indexOf(newAA);
            activeAnchor = newAA;
            this.ghostAnchor.addClass(newAA);
        }
        let p1 = new Point2D_1.Point2D(Math.min(x1, x2), Math.min(y1, y2)).boundToRect(this.paperRect);
        let p2 = new Point2D_1.Point2D(Math.max(x1, x2), Math.max(y1, y2)).boundToRect(this.paperRect);
        let rd = this.regionData.copy();
        rd.setPoints([p1, new Point2D_1.Point2D(p2.x, p1.y), p2, new Point2D_1.Point2D(p1.x, p2.y)]);
        this.onChange(this, rd, IRegionCallbacks_1.ChangeEventType.MOVING);
    }
    onGhostPointerEnter(e) {
        this.ghostAnchor.addClass(this.getActiveAnchor());
        super.onGhostPointerEnter(e);
    }
    onGhostPointerLeave(e) {
        this.ghostAnchor.removeClass(this.getActiveAnchor());
        super.onGhostPointerLeave(e);
    }
}
exports.AnchorsElement = AnchorsElement;
//# sourceMappingURL=AnchorsElements.js.map